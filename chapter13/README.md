# ユーティリティトレイト

標準ライブラリには、組み込みトレイトを使って機能をフックできる場所が設けられている。

* Dropトレイトを使って、C++のデストラクタのような、値がスコープから出た際んい後始末するするコードを書くことができる。
* Box<T>やRc<T>のようなスマートポインタ型ではDerefトレイトを実装して、参照しいている値のメソッドをポインタ型で使えるようにすることが出来る。
* From<T>トレイトとInto<T>トレイトを実装することで、ある型から別の方への変換を指示することができる。

## Drop


## Sized

sized型は、その型の値のメモリー上でのサイズが常に同じになるような型だ。RustRustのほとんどの型はsizedだ。
全てのu64は8バイト、全ての(f32, f32, f32)型のタプルは12バイトとなる。
列挙型でさえsizedだ。どのヴァリアントが実際に使われているか関わらず、常に最大のヴァリアントを保持できる空間を保有するからだ。
Vec<T>は可変サイズのバッファをヒープ上に保有するが、Vec値そのものはバッファへのポインタと容量と長さだけなので、Vec<T>もsizedとなる
しかし、Rustには数くないがunsignedな型も存在する。それらの型の値のサイズは一定ではない。
例えば、文字列スライス型str(&がついていないことに注意)はunsizedだ。文字列リテラル"diminutive"や"big"はそれぞれ10バイトと3バイトを
占めるstrのスライスへの参照である。
[T]のような配列スライス型(ここでも&がないことに注意)もuniszedだ。&[u8]のような共有参照は任意のサイズの[u8]スライスを指すことができる。
strや[T]は様々なサイズの値の集合を表すので。unsizedになる。

一般的に用いられるもう一つのunsized型として、トレイトオブジェクトの参照先が挙げられる。
トレイトオブジェクトはあるトレイトを実装した何らかの値へのポインタだ。
たとえば &std::io::WriteやBox<std::io::Write>は、Writeトレイトを実装した何らかの値のポインタだ。
参照されている値は、ファイルかもしれないし、ネットワークソケットかもしれないし、誰かが独自にWriteトレイトを実装した何らかの型かもしれない。
Writeを実素王するかもしれない片野尾集合は閉じていないので、Writeはunsizedになる。サイズは定まらない。

 Rustではunsizedのお値を変数に格納したり、引数として渡すことはできない。
&strやBox<Write>のようにポインタを介して扱うことしかできない。ポインタはサイズが決まっている。

unsizedの値へのポインタは常に２ワード長のファットポインタとなる。
スライスのポインタはスライスの長さも保持する。
トレイトオブジェクトはメソッド実装へのvtablleも保持している。
 トレイトオブジェクトとスライスへのポインタは綺麗に対象をなしている。いずれの場合も、型にはそれをつか合うための十分な情報がない。
[u8]をインデックスするには長さがわかっていなければならないし、Box<Write>のメソッドをよびだすには、参照されている値に適したWriteの
実装がわかっていなけばなならない。いずれの場合も、ファットポインタが、長さやvtableのポインタを与えることで、型にかけている情報を補う。

全てのsizedな型はstd::marker::Sizedトレイトっを実装している。このトレイトにはメソッドも関連型もない。
Rustは適用できる全ての型に対して自動的にこのトレイトを実装する。独自にコンパイルすることはできない。Sizedは、型変数の制約にしか使えない。
T: Sizedという制約はTがコンパイル時にサイズの決まる型であることを要求する。この種のトレイトはマーカートレイトと呼ばれ、Rust言語そのもおノオが何らかの
性質を持つ事をマークする為に使うからだ。

## Clone

## Copy

# DerefとDerefMut

std::ops::Derefトレイトやstd::ops::DerefMutトレイトを実装することで、その型に対する *や .なあどの参照解決演算子の動作を指定できる。
Box<T>やRc<T>などのポインタ型はこれらのトレイトを実装する事で、Rust組み込みポインタ型と同じように振る舞うようにしている。
derefメソッドやderef_mutメソッドは&Self参照を受けとり、&Self::Target参照を返す。
TargetはSelfが所有しているか、参照している型だ。
例えば  Box <Complex>ではTarget型はComplexになる。
DerefMutはDerefを拡張知っていることに注意しよう。何らかあの参照解決して変更できるのであれば、当然共有参照の借用もできるはずだからだ。
っこれらのメソッドは&selfと同じ生存期間を持つ参照を返すので、selfは変えされた参照が生きている間はずっと借用されたままになる。

> [!IMPORTANT]
> DerefとDerefMutトレイトは別の役割も果たす。derefメソッドは&Self参照を受け取り&Self::Target参照を返すので、Rustはこれを
> 前者から後者への自動変換にも用いる。つまり、derefを呼び出すことで型の不整合が防げるなら、Rustは自動的にderefを呼び出すということだ。
> DerefMutを実装していれば、可変参照に対する同様の変換が行われる。
> これらは、参照解決型変換と呼ばれている。ある型に、別の方のように振る舞う事を強制するのだ。

> [!TIP]
> DerefトレイトとDerefMutトレイトは、Box、Rc、Arcなどのスマートポインタがアタを実装する為に設計されている。
> また参照で使う場合が多い型の「所有バージョン」を実装するにも適している。
> 例えは、Vec<T>は[T]の、Stringはstrの所有バージョンだ。

## Default

Default::default()で、デフォルト値で全てのフィールドを初期化するには ..構文を使う。


> [!IMPORTANT]
ある型TがDefaultを実装していれば、標準ライブラリが自動的にRC<T>、Arc<T>、Box<T>、Cell<T>、
RefCell<T>、Cow<T>、Mutex<T>、RwLock<T>についてもDefaultを実装してくれる。
例えばRc<T>のデフォルト値は、型Tのデフォルト値を参照するRcとなる。

```rust
trait Default {
    fn default() -> Self;
}
```

タプルの全ての要素がDefaultを実装していれば、そのタプル型もお実装していることになり、個々の要素の
デフォルト値を保持したタプルがデフォルト値になる。

## AsRefとAsMut

`AsRef`と`AsMut`は、Rustの標準ライブラリに含まれるトレイトで、異なる型の参照を扱う際に使われます。これらは、構造体や関数間で参照を変換するための柔軟な方法を提供します。具体的には、`AsRef`は不変の参照を、`AsMut`は可変の参照を提供するために使われます。

### 1. `AsRef` トレイト

`AsRef`は、ある型から参照を借用する際に使用します。これは、元の型から参照を取得し、その参照が別の型として扱われるべき場合に役立ちます。

```rust
pub trait AsRef<T: ?Sized> {
    fn as_ref(&self) -> &T;
}
```

#### 使い方の例

```rust
fn print_as_ref<T: AsRef<str>>(input: T) {
    let s: &str = input.as_ref();
    println!("{}", s);
}

fn main() {
    let s = String::from("Hello");
    print_as_ref(s);  // String型でもAsRef<str>が実装されているためOK
}
```

この場合、`String`は`str`に対して`AsRef<str>`が実装されているため、`String`型の値を関数に渡すことができ、関数内で不変の`&str`参照として扱われます。

#### `AsRef`の利点

- **効率的な型変換**: 値をコピーせずに、異なる型間で安全に参照を取得できます。
- **柔軟なインターフェース設計**: 関数や構造体のインターフェースで汎用的な型を扱う際に便利です。

### 2. `AsMut` トレイト

`AsMut`は、`AsRef`と似ていますが、可変の参照を取得するために使用されます。

```rust
pub trait AsMut<T: ?Sized> {
    fn as_mut(&mut self) -> &mut T;
}
```

#### 使い方の例

```rust
fn modify_as_mut<T: AsMut<str>>(input: &mut T) {
    let s: &mut str = input.as_mut();
    s.make_ascii_uppercase();
}

fn main() {
    let mut s = String::from("Hello");
    modify_as_mut(&mut s);
    println!("{}", s);  // HELLO
}
```

この例では、`String`が`AsMut<str>`を実装しているため、`modify_as_mut`関数内で`&mut str`として可変参照が取得できます。

#### `AsMut`の利点

- **可変参照の安全な取得**: 元の型から別の型への可変参照を取得し、直接変更を加えることができます。
- **効率的な可変アクセス**: 値を再構築することなく、可変の参照を効率的に扱えます。

### まとめ

- **`AsRef`** は、ある型の不変の参照を取得し、異なる型として扱うトレイトです。
- **`AsMut`** は、ある型の可変の参照を取得して、異なる型に対して変更を加えることができるトレイトです。
- これらを使うと、汎用的で効率的なインターフェース設計が可能になります。

`AsRef`と`AsMut`は、型間の変換を容易にするため、Rustの多くの標準ライブラリやユーザー定義のコードで利用されています。