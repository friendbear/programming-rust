# ユーティリティトレイト

標準ライブラリには、組み込みトレイトを使って機能をフックできる場所が設けられている。

* Dropトレイトを使って、C++のデストラクタのような、値がスコープから出た際んい後始末するするコードを書くことができる。
* Box<T>やRc<T>のようなスマートポインタ型ではDerefトレイトを実装して、参照しいている値のメソッドをポインタ型で使えるようにすることが出来る。
* From<T>トレイトとInto<T>トレイトを実装することで、ある型から別の方への変換を指示することができる。

## Drop


## Sized

sized型は、その型の値のメモリー上でのサイズが常に同じになるような型だ。RustRustのほとんどの型はsizedだ。
全てのu64は8バイト、全ての(f32, f32, f32)型のタプルは12バイトとなる。
列挙型でさえsizedだ。どのヴァリアントが実際に使われているか関わらず、常に最大のヴァリアントを保持できる空間を保有するからだ。
Vec<T>は可変サイズのバッファをヒープ上に保有するが、Vec値そのものはバッファへのポインタと容量と長さだけなので、Vec<T>もsizedとなる
しかし、Rustには数くないがunsignedな型も存在する。それらの型の値のサイズは一定ではない。
例えば、文字列スライス型str(&がついていないことに注意)はunsizedだ。文字列リテラル"diminutive"や"big"はそれぞれ10バイトと3バイトを
占めるstrのスライスへの参照である。
[T]のような配列スライス型(ここでも&がないことに注意)もuniszedだ。&[u8]のような共有参照は任意のサイズの[u8]スライスを指すことができる。
strや[T]は様々なサイズの値の集合を表すので。unsizedになる。

一般的に用いられるもう一つのunsized型として、トレイトオブジェクトの参照先が挙げられる。
トレイトオブジェクトはあるトレイトを実装した何らかの値へのポインタだ。
たとえば &std::io::WriteやBox<std::io::Write>は、Writeトレイトを実装した何らかの値のポインタだ。
参照されている値は、ファイルかもしれないし、ネットワークソケットかもしれないし、誰かが独自にWriteトレイトを実装した何らかの型かもしれない。
Writeを実素王するかもしれない片野尾集合は閉じていないので、Writeはunsizedになる。サイズは定まらない。

 Rustではunsizedのお値を変数に格納したり、引数として渡すことはできない。
&strやBox<Write>のようにポインタを介して扱うことしかできない。ポインタはサイズが決まっている。

unsizedの値へのポインタは常に２ワード長のファットポインタとなる。
スライスのポインタはスライスの長さも保持する。
トレイトオブジェクトはメソッド実装へのvtablleも保持している。
 トレイトオブジェクトとスライスへのポインタは綺麗に対象をなしている。いずれの場合も、型にはそれをつか合うための十分な情報がない。
[u8]をインデックスするには長さがわかっていなければならないし、Box<Write>のメソッドをよびだすには、参照されている値に適したWriteの
実装がわかっていなけばなならない。いずれの場合も、ファットポインタが、長さやvtableのポインタを与えることで、型にかけている情報を補う。

全てのsizedな型はstd::marker::Sizedトレイトっを実装している。このトレイトにはメソッドも関連型もない。
Rustは適用できる全ての型に対して自動的にこのトレイトを実装する。独自にコンパイルすることはできない。Sizedは、型変数の制約にしか使えない。
T: Sizedという制約はTがコンパイル時にサイズの決まる型であることを要求する。この種のトレイトはマーカートレイトと呼ばれ、Rust言語そのもおノオが何らかの
性質を持つ事をマークする為に使うからだ。
