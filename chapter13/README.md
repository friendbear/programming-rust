# ユーティリティトレイト

標準ライブラリには、組み込みトレイトを使って機能をフックできる場所が設けられている。

* Dropトレイトを使って、C++のデストラクタのような、値がスコープから出た際んい後始末するするコードを書くことができる。
* Box<T>やRc<T>のようなスマートポインタ型ではDerefトレイトを実装して、参照しいている値のメソッドをポインタ型で使えるようにすることが出来る。
* From<T>トレイトとInto<T>トレイトを実装することで、ある型から別の方への変換を指示することができる。

## Drop


## Sized

sized型は、その型の値のメモリー上でのサイズが常に同じになるような型だ。RustRustのほとんどの型はsizedだ。
全てのu64は8バイト、全ての(f32, f32, f32)型のタプルは12バイトとなる。
列挙型でさえsizedだ。どのヴァリアントが実際に使われているか関わらず、常に最大のヴァリアントを保持できる空間を保有するからだ。
Vec<T>は可変サイズのバッファをヒープ上に保有するが、Vec値そのものはバッファへのポインタと容量と長さだけなので、Vec<T>もsizedとなる
しかし、Rustには数くないがunsignedな型も存在する。それらの型の値のサイズは一定ではない。
例えば、文字列スライス型str(&がついていないことに注意)はunsizedだ。文字列リテラル"diminutive"や"big"はそれぞれ10バイトと3バイトを
占めるstrのスライスへの参照である。
[T]のような配列スライス型(ここでも&がないことに注意)もuniszedだ。&[u8]のような共有参照は任意のサイズの[u8]スライスを指すことができる。
strや[T]は様々なサイズの値の集合を表すので。unsizedになる。

一般的に用いられるもう一つのunsized型として、トレイトオブジェクトの参照先が挙げられる。
トレイトオブジェクトはあるトレイトを実装した何らかの値へのポインタだ。
たとえば &std::io::WriteやBox<std::io::Write>は、Writeトレイトを実装した何らかの値のポインタだ。
参照されている値は、ファイルかもしれないし、ネットワークソケットかもしれないし、誰かが独自にWriteトレイトを実装した何らかの型かもしれない。
Writeを実素王するかもしれない片野尾集合は閉じていないので、Writeはunsizedになる。サイズは定まらない。

 Rustではunsizedのお値を変数に格納したり、引数として渡すことはできない。
&strやBox<Write>のようにポインタを介して扱うことしかできない。ポインタはサイズが決まっている。

unsizedの値へのポインタは常に２ワード長のファットポインタとなる。
スライスのポインタはスライスの長さも保持する。
トレイトオブジェクトはメソッド実装へのvtablleも保持している。
 トレイトオブジェクトとスライスへのポインタは綺麗に対象をなしている。いずれの場合も、型にはそれをつか合うための十分な情報がない。
[u8]をインデックスするには長さがわかっていなければならないし、Box<Write>のメソッドをよびだすには、参照されている値に適したWriteの
実装がわかっていなけばなならない。いずれの場合も、ファットポインタが、長さやvtableのポインタを与えることで、型にかけている情報を補う。

全てのsizedな型はstd::marker::Sizedトレイトっを実装している。このトレイトにはメソッドも関連型もない。
Rustは適用できる全ての型に対して自動的にこのトレイトを実装する。独自にコンパイルすることはできない。Sizedは、型変数の制約にしか使えない。
T: Sizedという制約はTがコンパイル時にサイズの決まる型であることを要求する。この種のトレイトはマーカートレイトと呼ばれ、Rust言語そのもおノオが何らかの
性質を持つ事をマークする為に使うからだ。

## Clone

## Copy

# DerefとDerefMut

std::ops::Derefトレイトやstd::ops::DerefMutトレイトを実装することで、その型に対する *や .なあどの参照解決演算子の動作を指定できる。
Box<T>やRc<T>などのポインタ型はこれらのトレイトを実装する事で、Rust組み込みポインタ型と同じように振る舞うようにしている。
derefメソッドやderef_mutメソッドは&Self参照を受けとり、&Self::Target参照を返す。
TargetはSelfが所有しているか、参照している型だ。
例えば  Box <Complex>ではTarget型はComplexになる。
DerefMutはDerefを拡張知っていることに注意しよう。何らかあの参照解決して変更できるのであれば、当然共有参照の借用もできるはずだからだ。
っこれらのメソッドは&selfと同じ生存期間を持つ参照を返すので、selfは変えされた参照が生きている間はずっと借用されたままになる。

> [!IMPORTANT]
> DerefとDerefMutトレイトは別の役割も果たす。derefメソッドは&Self参照を受け取り&Self::Target参照を返すので、Rustはこれを
> 前者から後者への自動変換にも用いる。つまり、derefを呼び出すことで型の不整合が防げるなら、Rustは自動的にderefを呼び出すということだ。
> DerefMutを実装していれば、可変参照に対する同様の変換が行われる。
> これらは、参照解決型変換と呼ばれている。ある型に、別の方のように振る舞う事を強制するのだ。

> [!TIP]
> DerefトレイトとDerefMutトレイトは、Box、Rc、Arcなどのスマートポインタがアタを実装する為に設計されている。
> また参照で使う場合が多い型の「所有バージョン」を実装するにも適している。
> 例えは、Vec<T>は[T]の、Stringはstrの所有バージョンだ。

## Default

Default::default()で、デフォルト値で全てのフィールドを初期化するには ..構文を使う。


> [!IMPORTANT]
ある型TがDefaultを実装していれば、標準ライブラリが自動的にRC<T>、Arc<T>、Box<T>、Cell<T>、
RefCell<T>、Cow<T>、Mutex<T>、RwLock<T>についてもDefaultを実装してくれる。
例えばRc<T>のデフォルト値は、型Tのデフォルト値を参照するRcとなる。

```rust
trait Default {
    fn default() -> Self;
}
```

タプルの全ての要素がDefaultを実装していれば、そのタプル型もお実装していることになり、個々の要素の
デフォルト値を保持したタプルがデフォルト値になる。